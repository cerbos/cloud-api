// Code generated by protoc-gen-go-hashpb. DO NOT EDIT.
// protoc-gen-go-hashpb v0.5.0

package logsv1

import (
	v1 "github.com/cerbos/cerbos/api/genpb/cerbos/audit/v1"
	v12 "github.com/cerbos/cerbos/api/genpb/cerbos/engine/v1"
	v13 "github.com/cerbos/cerbos/api/genpb/cerbos/policy/v1"
	v14 "github.com/cerbos/cerbos/api/genpb/cerbos/schema/v1"
	v11 "github.com/cerbos/cloud-api/genpb/cerbos/cloud/pdp/v1"
	protowire "google.golang.org/protobuf/encoding/protowire"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	hash "hash"
	maps "maps"
	math "math"
	slices "slices"
	sync "sync"
	unsafe "unsafe"
)

var hashpb_bufPool = sync.Pool{
	New: func() any { return new([10]byte) },
}

var hashpb_stringKeyPool = sync.Pool{
	New: func() any { return make([]string, 0, 32) },
}

var hashpb_int32KeyPool = sync.Pool{
	New: func() any { return make([]int32, 0, 32) },
}

var hashpb_int64KeyPool = sync.Pool{
	New: func() any { return make([]int64, 0, 32) },
}

var hashpb_uint32KeyPool = sync.Pool{
	New: func() any { return make([]uint32, 0, 32) },
}

var hashpb_uint64KeyPool = sync.Pool{
	New: func() any { return make([]uint64, 0, 32) },
}

func cerbos_audit_v1_AccessLogEntry_hashpb_sum(m *v1.AccessLogEntry, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.AccessLogEntry.call_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetCallId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetCallId()), len(m.GetCallId())))
	}
	if _, ok := ignore["cerbos.audit.v1.AccessLogEntry.timestamp"]; !ok {
		if m.GetTimestamp() != nil {
			google_protobuf_Timestamp_hashpb_sum(m.GetTimestamp(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.audit.v1.AccessLogEntry.peer"]; !ok {
		if m.GetPeer() != nil {
			cerbos_audit_v1_Peer_hashpb_sum(m.GetPeer(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.audit.v1.AccessLogEntry.metadata"]; !ok {
		if len(m.Metadata) > 0 {
			if len(m.Metadata) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Metadata {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Metadata[k] != nil {
						cerbos_audit_v1_MetaValues_hashpb_sum(m.Metadata[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Metadata)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Metadata[k] != nil {
						cerbos_audit_v1_MetaValues_hashpb_sum(m.Metadata[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.AccessLogEntry.method"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetMethod()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetMethod()), len(m.GetMethod())))
	}
	if _, ok := ignore["cerbos.audit.v1.AccessLogEntry.status_code"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetStatusCode())))
	}
}

func cerbos_audit_v1_AuditTrail_hashpb_sum(m *v1.AuditTrail, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.AuditTrail.effective_policies"]; !ok {
		if len(m.EffectivePolicies) > 0 {
			if len(m.EffectivePolicies) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.EffectivePolicies {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.EffectivePolicies[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.EffectivePolicies[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.EffectivePolicies)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.EffectivePolicies[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.EffectivePolicies[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_audit_v1_DecisionLogEntry_CheckResources_hashpb_sum(m *v1.DecisionLogEntry_CheckResources, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.CheckResources.inputs"]; !ok {
		if len(m.Inputs) > 0 {
			for _, v := range m.Inputs {
				if v != nil {
					cerbos_engine_v1_CheckInput_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.CheckResources.outputs"]; !ok {
		if len(m.Outputs) > 0 {
			for _, v := range m.Outputs {
				if v != nil {
					cerbos_engine_v1_CheckOutput_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.CheckResources.error"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetError()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetError()), len(m.GetError())))
	}
}

func cerbos_audit_v1_DecisionLogEntry_PlanResources_hashpb_sum(m *v1.DecisionLogEntry_PlanResources, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.PlanResources.input"]; !ok {
		if m.GetInput() != nil {
			cerbos_engine_v1_PlanResourcesInput_hashpb_sum(m.GetInput(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.PlanResources.output"]; !ok {
		if m.GetOutput() != nil {
			cerbos_engine_v1_PlanResourcesOutput_hashpb_sum(m.GetOutput(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.PlanResources.error"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetError()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetError()), len(m.GetError())))
	}
}

func cerbos_audit_v1_DecisionLogEntry_hashpb_sum(m *v1.DecisionLogEntry, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.call_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetCallId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetCallId()), len(m.GetCallId())))
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.timestamp"]; !ok {
		if m.GetTimestamp() != nil {
			google_protobuf_Timestamp_hashpb_sum(m.GetTimestamp(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.peer"]; !ok {
		if m.GetPeer() != nil {
			cerbos_audit_v1_Peer_hashpb_sum(m.GetPeer(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.inputs"]; !ok {
		if len(m.Inputs) > 0 {
			for _, v := range m.Inputs {
				if v != nil {
					cerbos_engine_v1_CheckInput_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.outputs"]; !ok {
		if len(m.Outputs) > 0 {
			for _, v := range m.Outputs {
				if v != nil {
					cerbos_engine_v1_CheckOutput_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.error"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetError()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetError()), len(m.GetError())))
	}
	if m.Method != nil {
		if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.method"]; !ok {
			switch t := m.Method.(type) {
			case *v1.DecisionLogEntry_CheckResources_:
				if t.CheckResources != nil {
					cerbos_audit_v1_DecisionLogEntry_CheckResources_hashpb_sum(t.CheckResources, hasher, ignore, b)
				}
			case *v1.DecisionLogEntry_PlanResources_:
				if t.PlanResources != nil {
					cerbos_audit_v1_DecisionLogEntry_PlanResources_hashpb_sum(t.PlanResources, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.metadata"]; !ok {
		if len(m.Metadata) > 0 {
			if len(m.Metadata) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Metadata {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Metadata[k] != nil {
						cerbos_audit_v1_MetaValues_hashpb_sum(m.Metadata[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Metadata)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Metadata[k] != nil {
						cerbos_audit_v1_MetaValues_hashpb_sum(m.Metadata[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.audit.v1.DecisionLogEntry.audit_trail"]; !ok {
		if m.GetAuditTrail() != nil {
			cerbos_audit_v1_AuditTrail_hashpb_sum(m.GetAuditTrail(), hasher, ignore, b)
		}
	}
}

func cerbos_audit_v1_MetaValues_hashpb_sum(m *v1.MetaValues, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.MetaValues.values"]; !ok {
		if len(m.Values) > 0 {
			for _, v := range m.Values {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
}

func cerbos_audit_v1_Peer_hashpb_sum(m *v1.Peer, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.audit.v1.Peer.address"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetAddress()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetAddress()), len(m.GetAddress())))
	}
	if _, ok := ignore["cerbos.audit.v1.Peer.auth_info"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetAuthInfo()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetAuthInfo()), len(m.GetAuthInfo())))
	}
	if _, ok := ignore["cerbos.audit.v1.Peer.user_agent"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetUserAgent()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetUserAgent()), len(m.GetUserAgent())))
	}
	if _, ok := ignore["cerbos.audit.v1.Peer.forwarded_for"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetForwardedFor()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetForwardedFor()), len(m.GetForwardedFor())))
	}
}

func cerbos_cloud_logs_v1_IngestBatch_Entry_hashpb_sum(m *IngestBatch_Entry, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestBatch.Entry.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetKind())))
	}
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestBatch.Entry.timestamp"]; !ok {
		if m.GetTimestamp() != nil {
			google_protobuf_Timestamp_hashpb_sum(m.GetTimestamp(), hasher, ignore, b)
		}
	}
	if m.Entry != nil {
		if _, ok := ignore["cerbos.cloud.logs.v1.IngestBatch.Entry.entry"]; !ok {
			switch t := m.Entry.(type) {
			case *IngestBatch_Entry_AccessLogEntry:
				if t.AccessLogEntry != nil {
					cerbos_audit_v1_AccessLogEntry_hashpb_sum(t.AccessLogEntry, hasher, ignore, b)
				}
			case *IngestBatch_Entry_DecisionLogEntry:
				if t.DecisionLogEntry != nil {
					cerbos_audit_v1_DecisionLogEntry_hashpb_sum(t.DecisionLogEntry, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_cloud_logs_v1_IngestBatch_hashpb_sum(m *IngestBatch, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestBatch.id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetId()), len(m.GetId())))
	}
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestBatch.entries"]; !ok {
		if len(m.Entries) > 0 {
			for _, v := range m.Entries {
				if v != nil {
					cerbos_cloud_logs_v1_IngestBatch_Entry_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_cloud_logs_v1_IngestRequest_hashpb_sum(m *IngestRequest, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestRequest.pdp_id"]; !ok {
		if m.GetPdpId() != nil {
			cerbos_cloud_pdp_v1_Identifier_hashpb_sum(m.GetPdpId(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestRequest.batch"]; !ok {
		if m.GetBatch() != nil {
			cerbos_cloud_logs_v1_IngestBatch_hashpb_sum(m.GetBatch(), hasher, ignore, b)
		}
	}
}

func cerbos_cloud_logs_v1_IngestResponse_Backoff_hashpb_sum(m *IngestResponse_Backoff, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.cloud.logs.v1.IngestResponse.Backoff.duration"]; !ok {
		if m.GetDuration() != nil {
			google_protobuf_Duration_hashpb_sum(m.GetDuration(), hasher, ignore, b)
		}
	}
}

func cerbos_cloud_logs_v1_IngestResponse_hashpb_sum(m *IngestResponse, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Status != nil {
		if _, ok := ignore["cerbos.cloud.logs.v1.IngestResponse.status"]; !ok {
			switch t := m.Status.(type) {
			case *IngestResponse_Success:
				if t.Success != nil {
					google_protobuf_Empty_hashpb_sum(t.Success, hasher, ignore, b)
				}
			case *IngestResponse_Backoff_:
				if t.Backoff != nil {
					cerbos_cloud_logs_v1_IngestResponse_Backoff_hashpb_sum(t.Backoff, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_cloud_pdp_v1_Identifier_hashpb_sum(m *v11.Identifier, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.cloud.pdp.v1.Identifier.instance"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetInstance()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetInstance()), len(m.GetInstance())))
	}
	if _, ok := ignore["cerbos.cloud.pdp.v1.Identifier.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
}

func cerbos_engine_v1_AuxData_hashpb_sum(m *v12.AuxData, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.AuxData.jwt"]; !ok {
		if len(m.Jwt) > 0 {
			if len(m.Jwt) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Jwt {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Jwt[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Jwt[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Jwt)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Jwt[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Jwt[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_engine_v1_CheckInput_hashpb_sum(m *v12.CheckInput, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.CheckInput.request_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRequestId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRequestId()), len(m.GetRequestId())))
	}
	if _, ok := ignore["cerbos.engine.v1.CheckInput.resource"]; !ok {
		if m.GetResource() != nil {
			cerbos_engine_v1_Resource_hashpb_sum(m.GetResource(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.engine.v1.CheckInput.principal"]; !ok {
		if m.GetPrincipal() != nil {
			cerbos_engine_v1_Principal_hashpb_sum(m.GetPrincipal(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.engine.v1.CheckInput.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.CheckInput.aux_data"]; !ok {
		if m.GetAuxData() != nil {
			cerbos_engine_v1_AuxData_hashpb_sum(m.GetAuxData(), hasher, ignore, b)
		}
	}
}

func cerbos_engine_v1_CheckOutput_ActionEffect_hashpb_sum(m *v12.CheckOutput_ActionEffect, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.ActionEffect.effect"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetEffect())))
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.ActionEffect.policy"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicy()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicy()), len(m.GetPolicy())))
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.ActionEffect.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
}

func cerbos_engine_v1_CheckOutput_hashpb_sum(m *v12.CheckOutput, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.request_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRequestId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRequestId()), len(m.GetRequestId())))
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.resource_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetResourceId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetResourceId()), len(m.GetResourceId())))
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.actions"]; !ok {
		if len(m.Actions) > 0 {
			if len(m.Actions) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Actions {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Actions[k] != nil {
						cerbos_engine_v1_CheckOutput_ActionEffect_hashpb_sum(m.Actions[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Actions)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Actions[k] != nil {
						cerbos_engine_v1_CheckOutput_ActionEffect_hashpb_sum(m.Actions[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.effective_derived_roles"]; !ok {
		if len(m.EffectiveDerivedRoles) > 0 {
			for _, v := range m.EffectiveDerivedRoles {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.validation_errors"]; !ok {
		if len(m.ValidationErrors) > 0 {
			for _, v := range m.ValidationErrors {
				if v != nil {
					cerbos_schema_v1_ValidationError_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.CheckOutput.outputs"]; !ok {
		if len(m.Outputs) > 0 {
			for _, v := range m.Outputs {
				if v != nil {
					cerbos_engine_v1_OutputEntry_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_engine_v1_OutputEntry_hashpb_sum(m *v12.OutputEntry, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.OutputEntry.src"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetSrc()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetSrc()), len(m.GetSrc())))
	}
	if _, ok := ignore["cerbos.engine.v1.OutputEntry.val"]; !ok {
		if m.GetVal() != nil {
			google_protobuf_Value_hashpb_sum(m.GetVal(), hasher, ignore, b)
		}
	}
}

func cerbos_engine_v1_PlanResourcesFilter_Expression_Operand_hashpb_sum(m *v12.PlanResourcesFilter_Expression_Operand, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Node != nil {
		if _, ok := ignore["cerbos.engine.v1.PlanResourcesFilter.Expression.Operand.node"]; !ok {
			switch t := m.Node.(type) {
			case *v12.PlanResourcesFilter_Expression_Operand_Value:
				if t.Value != nil {
					google_protobuf_Value_hashpb_sum(t.Value, hasher, ignore, b)
				}
			case *v12.PlanResourcesFilter_Expression_Operand_Expression:
				if t.Expression != nil {
					cerbos_engine_v1_PlanResourcesFilter_Expression_hashpb_sum(t.Expression, hasher, ignore, b)
				}
			case *v12.PlanResourcesFilter_Expression_Operand_Variable:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.Variable))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.Variable), len(t.Variable)))
			}
		}
	}
}

func cerbos_engine_v1_PlanResourcesFilter_Expression_hashpb_sum(m *v12.PlanResourcesFilter_Expression, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesFilter.Expression.operator"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetOperator()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetOperator()), len(m.GetOperator())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesFilter.Expression.operands"]; !ok {
		if len(m.Operands) > 0 {
			for _, v := range m.Operands {
				if v != nil {
					cerbos_engine_v1_PlanResourcesFilter_Expression_Operand_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_engine_v1_PlanResourcesFilter_hashpb_sum(m *v12.PlanResourcesFilter, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesFilter.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetKind())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesFilter.condition"]; !ok {
		if m.GetCondition() != nil {
			cerbos_engine_v1_PlanResourcesFilter_Expression_Operand_hashpb_sum(m.GetCondition(), hasher, ignore, b)
		}
	}
}

func cerbos_engine_v1_PlanResourcesInput_Resource_hashpb_sum(m *v12.PlanResourcesInput_Resource, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.Resource.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetKind()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetKind()), len(m.GetKind())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.Resource.attr"]; !ok {
		if len(m.Attr) > 0 {
			if len(m.Attr) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Attr {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attr[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attr[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Attr)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attr[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attr[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.Resource.policy_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicyVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicyVersion()), len(m.GetPolicyVersion())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.Resource.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
}

func cerbos_engine_v1_PlanResourcesInput_hashpb_sum(m *v12.PlanResourcesInput, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.request_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRequestId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRequestId()), len(m.GetRequestId())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.action"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetAction()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetAction()), len(m.GetAction())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.principal"]; !ok {
		if m.GetPrincipal() != nil {
			cerbos_engine_v1_Principal_hashpb_sum(m.GetPrincipal(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.resource"]; !ok {
		if m.GetResource() != nil {
			cerbos_engine_v1_PlanResourcesInput_Resource_hashpb_sum(m.GetResource(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.aux_data"]; !ok {
		if m.GetAuxData() != nil {
			cerbos_engine_v1_AuxData_hashpb_sum(m.GetAuxData(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.include_meta"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(m.GetIncludeMeta())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesInput.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
}

func cerbos_engine_v1_PlanResourcesOutput_hashpb_sum(m *v12.PlanResourcesOutput, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.request_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRequestId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRequestId()), len(m.GetRequestId())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.action"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetAction()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetAction()), len(m.GetAction())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetKind()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetKind()), len(m.GetKind())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.policy_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicyVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicyVersion()), len(m.GetPolicyVersion())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.filter"]; !ok {
		if m.GetFilter() != nil {
			cerbos_engine_v1_PlanResourcesFilter_hashpb_sum(m.GetFilter(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.filter_debug"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFilterDebug()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFilterDebug()), len(m.GetFilterDebug())))
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.validation_errors"]; !ok {
		if len(m.ValidationErrors) > 0 {
			for _, v := range m.ValidationErrors {
				if v != nil {
					cerbos_schema_v1_ValidationError_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.PlanResourcesOutput.matched_scopes"]; !ok {
		if len(m.MatchedScopes) > 0 {
			if len(m.MatchedScopes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.MatchedScopes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.MatchedScopes[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.MatchedScopes[k]), len(m.MatchedScopes[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.MatchedScopes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.MatchedScopes[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.MatchedScopes[k]), len(m.MatchedScopes[k])))
				}
			}
		}
	}
}

func cerbos_engine_v1_Principal_hashpb_sum(m *v12.Principal, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.Principal.id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetId()), len(m.GetId())))
	}
	if _, ok := ignore["cerbos.engine.v1.Principal.policy_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicyVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicyVersion()), len(m.GetPolicyVersion())))
	}
	if _, ok := ignore["cerbos.engine.v1.Principal.roles"]; !ok {
		if len(m.Roles) > 0 {
			for _, v := range m.Roles {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.Principal.attr"]; !ok {
		if len(m.Attr) > 0 {
			if len(m.Attr) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Attr {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attr[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attr[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Attr)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attr[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attr[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.Principal.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
}

func cerbos_engine_v1_Resource_hashpb_sum(m *v12.Resource, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.engine.v1.Resource.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetKind()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetKind()), len(m.GetKind())))
	}
	if _, ok := ignore["cerbos.engine.v1.Resource.policy_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicyVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicyVersion()), len(m.GetPolicyVersion())))
	}
	if _, ok := ignore["cerbos.engine.v1.Resource.id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetId()), len(m.GetId())))
	}
	if _, ok := ignore["cerbos.engine.v1.Resource.attr"]; !ok {
		if len(m.Attr) > 0 {
			if len(m.Attr) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Attr {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attr[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attr[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Attr)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attr[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attr[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.engine.v1.Resource.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
}

func cerbos_policy_v1_SourceAttributes_hashpb_sum(m *v13.SourceAttributes, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.policy.v1.SourceAttributes.attributes"]; !ok {
		if len(m.Attributes) > 0 {
			if len(m.Attributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Attributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attributes[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Attributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attributes[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_schema_v1_ValidationError_hashpb_sum(m *v14.ValidationError, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.schema.v1.ValidationError.path"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPath()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPath()), len(m.GetPath())))
	}
	if _, ok := ignore["cerbos.schema.v1.ValidationError.message"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetMessage()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetMessage()), len(m.GetMessage())))
	}
	if _, ok := ignore["cerbos.schema.v1.ValidationError.source"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetSource())))
	}
}

func google_protobuf_Duration_hashpb_sum(m *durationpb.Duration, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Duration.seconds"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetSeconds())))
	}
	if _, ok := ignore["google.protobuf.Duration.nanos"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetNanos())))
	}
}

func google_protobuf_Empty_hashpb_sum(m *emptypb.Empty, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
}

func google_protobuf_ListValue_hashpb_sum(m *structpb.ListValue, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.ListValue.values"]; !ok {
		if len(m.Values) > 0 {
			for _, v := range m.Values {
				if v != nil {
					google_protobuf_Value_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_protobuf_Struct_hashpb_sum(m *structpb.Struct, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Struct.fields"]; !ok {
		if len(m.Fields) > 0 {
			if len(m.Fields) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Fields {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Fields[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Fields)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Fields[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func google_protobuf_Timestamp_hashpb_sum(m *timestamppb.Timestamp, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Timestamp.seconds"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetSeconds())))
	}
	if _, ok := ignore["google.protobuf.Timestamp.nanos"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetNanos())))
	}
}

func google_protobuf_Value_hashpb_sum(m *structpb.Value, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Kind != nil {
		if _, ok := ignore["google.protobuf.Value.kind"]; !ok {
			switch t := m.Kind.(type) {
			case *structpb.Value_NullValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.NullValue)))
			case *structpb.Value_NumberValue:
				_, _ = hasher.Write(protowire.AppendFixed64(b[:0], math.Float64bits(t.NumberValue)))
			case *structpb.Value_StringValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.StringValue))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.StringValue), len(t.StringValue)))
			case *structpb.Value_BoolValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(t.BoolValue)))
			case *structpb.Value_StructValue:
				if t.StructValue != nil {
					google_protobuf_Struct_hashpb_sum(t.StructValue, hasher, ignore, b)
				}
			case *structpb.Value_ListValue:
				if t.ListValue != nil {
					google_protobuf_ListValue_hashpb_sum(t.ListValue, hasher, ignore, b)
				}
			}
		}
	}
}
