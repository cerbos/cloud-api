// Code generated by protoc-gen-go-hashpb. DO NOT EDIT.
// protoc-gen-go-hashpb v0.5.0

package epdpv1

import (
	v1 "github.com/cerbos/cerbos/api/genpb/cerbos/policy/v1"
	protowire "google.golang.org/protobuf/encoding/protowire"
	structpb "google.golang.org/protobuf/types/known/structpb"
	hash "hash"
	maps "maps"
	math "math"
	slices "slices"
	sync "sync"
	unsafe "unsafe"
)

var hashpb_bufPool = sync.Pool{
	New: func() any { return new([10]byte) },
}

var hashpb_stringKeyPool = sync.Pool{
	New: func() any { return make([]string, 0, 32) },
}

var hashpb_int32KeyPool = sync.Pool{
	New: func() any { return make([]int32, 0, 32) },
}

var hashpb_int64KeyPool = sync.Pool{
	New: func() any { return make([]int64, 0, 32) },
}

var hashpb_uint32KeyPool = sync.Pool{
	New: func() any { return make([]uint32, 0, 32) },
}

var hashpb_uint64KeyPool = sync.Pool{
	New: func() any { return make([]uint64, 0, 32) },
}

func cerbos_cloud_epdp_v1_Metadata_hashpb_sum(m *Metadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.cloud.epdp.v1.Metadata.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
	if _, ok := ignore["cerbos.cloud.epdp.v1.Metadata.policies"]; !ok {
		if len(m.Policies) > 0 {
			for _, v := range m.Policies {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.cloud.epdp.v1.Metadata.build_timestamp"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetBuildTimestamp())))
	}
	if _, ok := ignore["cerbos.cloud.epdp.v1.Metadata.commit_hash"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetCommitHash()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetCommitHash()), len(m.GetCommitHash())))
	}
	if _, ok := ignore["cerbos.cloud.epdp.v1.Metadata.source_attributes"]; !ok {
		if len(m.SourceAttributes) > 0 {
			if len(m.SourceAttributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.SourceAttributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.SourceAttributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_policy_v1_SourceAttributes_hashpb_sum(m *v1.SourceAttributes, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.policy.v1.SourceAttributes.attributes"]; !ok {
		if len(m.Attributes) > 0 {
			if len(m.Attributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Attributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attributes[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Attributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attributes[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func google_protobuf_ListValue_hashpb_sum(m *structpb.ListValue, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.ListValue.values"]; !ok {
		if len(m.Values) > 0 {
			for _, v := range m.Values {
				if v != nil {
					google_protobuf_Value_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_protobuf_Struct_hashpb_sum(m *structpb.Struct, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Struct.fields"]; !ok {
		if len(m.Fields) > 0 {
			if len(m.Fields) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Fields {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Fields[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Fields)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Fields[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func google_protobuf_Value_hashpb_sum(m *structpb.Value, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Kind != nil {
		if _, ok := ignore["google.protobuf.Value.kind"]; !ok {
			switch t := m.Kind.(type) {
			case *structpb.Value_NullValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.NullValue)))
			case *structpb.Value_NumberValue:
				_, _ = hasher.Write(protowire.AppendFixed64(b[:0], math.Float64bits(t.NumberValue)))
			case *structpb.Value_StringValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.StringValue))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.StringValue), len(t.StringValue)))
			case *structpb.Value_BoolValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(t.BoolValue)))
			case *structpb.Value_StructValue:
				if t.StructValue != nil {
					google_protobuf_Struct_hashpb_sum(t.StructValue, hasher, ignore, b)
				}
			case *structpb.Value_ListValue:
				if t.ListValue != nil {
					google_protobuf_ListValue_hashpb_sum(t.ListValue, hasher, ignore, b)
				}
			}
		}
	}
}
